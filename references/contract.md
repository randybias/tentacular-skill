# Contract Model

The `contract` section in `workflow.yaml` is the
authoritative declaration of every external dependency
a workflow needs. It is a top-level peer of `nodes`,
`edges`, and `config`.

**Core principle: dependencies are the single primitive.**
A Tentacular workflow is a sealed pod that can only reach
declared network dependencies. Secrets, NetworkPolicy,
connection config, and validation are ALL derived from
the dependency list. There is no separate `secrets` or
`networkPolicy` section to author -- both are derived
automatically.

## Contract Structure

```yaml
contract:
  version: "1"
  dependencies:
    github-api:
      protocol: https
      host: api.github.com
      # port defaults to 443 for https
      auth:
        type: bearer-token
        secret: github.token
    postgres:
      protocol: postgresql
      host: db.svc.cluster.local
      # port defaults to 5432 for postgresql
      database: appdb
      user: postgres
      auth:
        type: password
        secret: postgres.password
    azure-blob:
      protocol: https
      host: myaccount.blob.core.windows.net
      auth:
        type: sas-token
        secret: azure-blob.sas_token
    slack-webhook:
      protocol: https
      host: hooks.slack.com
      auth:
        type: bearer-token
        secret: slack.webhook_url
```

## What Gets Derived

| Artifact | Source | Derivation |
|----------|--------|------------|
| Required secrets | `dep.auth.secret` | Collect all auth secret refs |
| Egress NetworkPolicy | `dep.host` + `dep.port` | One allow rule per dep + DNS |
| Ingress NetworkPolicy | `triggers[].type` | Webhook: open ingress; else label-scoped (trigger pods only) |
| Connection config | `dep.*` metadata | Injected via `ctx.dependency()` |

## Dependency Protocols

The `protocol` field accepts any string. Known
protocols (`https`, `postgresql`, `nats`, `blob`)
get field validation and default ports. Unknown
protocols are accepted with a warning, enabling
custom protocol types without parser changes.

Known protocols and their metadata fields:

- **https**: host, port (default 443), auth
- **postgresql**: host, port (default 5432),
  database, user, auth
- **nats**: host, port (default 4222), auth,
  subject
- **blob**: host, port (default 443), auth,
  container

## Auth Types

Auth types are declared explicitly via `auth.type`
in the contract. The value is any string identifying
the auth mechanism (e.g., `bearer-token`, `api-key`,
`sas-token`, `password`, `hmac-sha256`). There is no
closed vocabulary -- use whatever describes your auth
scheme. The `authType` field on `DependencyConnection`
reflects this declared value. Nodes use `dep.authType`
and `dep.secret` to handle auth explicitly.

## Minimal Contract (No Dependencies)

Workflows with no external dependencies use an empty
dependency map:

```yaml
contract:
  version: "1"
  dependencies: {}
```

## NetworkPolicy Overrides

For edge cases not derivable from dependencies, use
optional overrides:

```yaml
contract:
  version: "1"
  dependencies: { ... }
  networkPolicy:
    additionalEgress:
      - toCIDR: 10.0.0.0/8
        ports:
          - port: 8080
            protocol: TCP
        reason: "internal service mesh"
```

## Dynamic-Target Dependencies

For dependencies where the target is not a fixed
hostname (e.g., IP-based services, cloud metadata
endpoints, or dynamically discovered peers), use
`type: "dynamic-target"`:

```yaml
contract:
  version: "1"
  dependencies:
    cloud-metadata:
      type: "dynamic-target"
      cidr: 169.254.169.254/32
      dynPorts:
        - port: 80
          protocol: TCP
      reason: "cloud instance metadata endpoint"
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| `type` | string | Must be `"dynamic-target"` |
| `cidr` | string | CIDR block for egress rule (e.g., `10.0.0.0/8`) |
| `dynPorts` | array | List of `{port, protocol}` objects for egress |
| `reason` | string | Human-readable explanation for audit trail |

### Validation

- `cidr` must be a valid CIDR notation
- `dynPorts` must have at least one entry
- `reason` is required (explains why a fixed host is not used)
- Dynamic-target dependencies generate CIDR-based
  egress rules instead of hostname-based DNS rules

## Label-Scoped Ingress

For non-webhook workflows (manual, cron, queue
triggers), ingress is scoped to pods with the
`tentacular.dev/role: trigger` label rather than
fully open.

CronJob pods generated by `tntc deploy` automatically
receive this label. This means only trigger pods
(CronJobs, manual run pods) can reach the workflow
service -- not arbitrary pods in the namespace.

Webhook workflows use open ingress to allow external
traffic through an ingress controller or gateway.

### Label assignment

| Resource | Label | Applied by |
|----------|-------|------------|
| CronJob pods | `tentacular.dev/role: trigger` | `tntc deploy` manifest generation |
| Manual run pods | `tentacular.dev/role: trigger` | `tntc run` pod spec |
| Workflow Deployment | `app.kubernetes.io/name: <wf>` | `tntc deploy` manifest generation |

### NetworkPolicy effect

```yaml
# Generated for non-webhook workflows
ingress:
  - from:
      - podSelector:
          matchLabels:
            tentacular.dev/role: trigger
    ports:
      - port: 8080
        protocol: TCP
```

## Contract Enforcement

Contract enforcement is **strict** by default. All
workflows are held to the same standard.

In strict mode, `tntc test` fails on any contract
drift. Use `--warn` to downgrade violations to
warnings without failing the test:

```bash
tntc test                     # strict: violations fail
tntc test --warn              # audit: violations warn
```

Environment config can also set audit mode globally
for a development environment:

```yaml
# In .tentacular/config.yaml
environments:
  dev:
    enforcement: audit
```

## Drift Detection

`tntc test` runs runtime-tracing drift detection by
comparing actual code behavior against contract
declarations. The mock context records all access
patterns during test execution.

**Violation types:**

| Type | Meaning | Suggestion |
|------|---------|------------|
| `direct-fetch` | Code uses `ctx.fetch()` instead of `ctx.dependency().fetch()` | Migrate to `ctx.dependency()` |
| `direct-secrets` | Code reads `ctx.secrets` directly | Use `ctx.dependency().secret` |
| `undeclared-dependency` | Code calls `ctx.dependency(name)` for a dep not in the contract | Add to `contract.dependencies` |
| `dead-declaration` | Contract declares a dep that code never accesses | Remove from contract or add usage |

**Drift report output:**

```
=== Contract Drift Report ===

VIOLATIONS:
  [direct-fetch] Direct ctx.fetch("github", "/repos/test") bypasses contract
     Suggestion: Use ctx.dependency("github").fetch("/repos/test") instead
  [dead-declaration] Dependency "unused-api" declared in contract but never accessed
     Suggestion: Remove "unused-api" from contract.dependencies or ensure the node uses it

SUMMARY:
  Dependencies accessed: 2
  Direct fetch() calls: 1
  Direct secrets access: 0
  Dead declarations: 1
  Undeclared dependencies: 0
  Has violations: YES
```

With `-o json`, the drift report is included in the
test output envelope as a structured `drift` field.

## Extensibility

Extension fields are supported via `x-*` namespaced
keys. They are preserved through parsing and do not
break core schema validation.
